{"ast":null,"code":"/**\n * @fileoverview\n * @author Brandon Alexander - baalexander@gmail.com\n */\nvar ServiceResponse = require('./ServiceResponse');\n\nvar ServiceRequest = require('./ServiceRequest');\n\nvar EventEmitter2 = require('eventemitter2').EventEmitter2;\n/**\n * A ROS service client.\n *\n * @constructor\n * @params options - possible keys include:\n *   * ros - the ROSLIB.Ros connection handle\n *   * name - the service name, like /add_two_ints\n *   * serviceType - the service type, like 'rospy_tutorials/AddTwoInts'\n */\n\n\nfunction Service(options) {\n  options = options || {};\n  this.ros = options.ros;\n  this.name = options.name;\n  this.serviceType = options.serviceType;\n  this.isAdvertised = false;\n  this._serviceCallback = null;\n}\n\nService.prototype.__proto__ = EventEmitter2.prototype;\n/**\n * Calls the service. Returns the service response in the\n * callback. Does nothing if this service is currently advertised.\n *\n * @param request - the ROSLIB.ServiceRequest to send\n * @param callback - function with params:\n *   * response - the response from the service request\n * @param failedCallback - the callback function when the service call failed (optional). Params:\n *   * error - the error message reported by ROS\n */\n\nService.prototype.callService = function (request, callback, failedCallback) {\n  if (this.isAdvertised) {\n    return;\n  }\n\n  var serviceCallId = 'call_service:' + this.name + ':' + ++this.ros.idCounter;\n\n  if (callback || failedCallback) {\n    this.ros.once(serviceCallId, function (message) {\n      if (message.result !== undefined && message.result === false) {\n        if (typeof failedCallback === 'function') {\n          failedCallback(message.values);\n        }\n      } else if (typeof callback === 'function') {\n        callback(new ServiceResponse(message.values));\n      }\n    });\n  }\n\n  var call = {\n    op: 'call_service',\n    id: serviceCallId,\n    service: this.name,\n    type: this.serviceType,\n    args: request\n  };\n  this.ros.callOnConnection(call);\n};\n/**\n * Advertise the service. This turns the Service object from a client\n * into a server. The callback will be called with every request\n * that's made on this service.\n *\n * @param callback - This works similarly to the callback for a C++ service and should take the following params:\n *   * request - the service request\n *   * response - an empty dictionary. Take care not to overwrite this. Instead, only modify the values within.\n *   It should return true if the service has finished successfully,\n *   i.e. without any fatal errors.\n */\n\n\nService.prototype.advertise = function (callback) {\n  if (this.isAdvertised || typeof callback !== 'function') {\n    return;\n  }\n\n  this._serviceCallback = callback;\n  this.ros.on(this.name, this._serviceResponse.bind(this));\n  this.ros.callOnConnection({\n    op: 'advertise_service',\n    type: this.serviceType,\n    service: this.name\n  });\n  this.isAdvertised = true;\n};\n\nService.prototype.unadvertise = function () {\n  if (!this.isAdvertised) {\n    return;\n  }\n\n  this.ros.callOnConnection({\n    op: 'unadvertise_service',\n    service: this.name\n  });\n  this.isAdvertised = false;\n};\n\nService.prototype._serviceResponse = function (rosbridgeRequest) {\n  var response = {};\n\n  var success = this._serviceCallback(rosbridgeRequest.args, response);\n\n  var call = {\n    op: 'service_response',\n    service: this.name,\n    values: new ServiceResponse(response),\n    result: success\n  };\n\n  if (rosbridgeRequest.id) {\n    call.id = rosbridgeRequest.id;\n  }\n\n  this.ros.callOnConnection(call);\n};\n\nmodule.exports = Service;","map":{"version":3,"sources":["/Users/julien/Sites/react-ros-robot/node_modules/roslib/src/core/Service.js"],"names":["ServiceResponse","require","ServiceRequest","EventEmitter2","Service","options","ros","name","serviceType","isAdvertised","_serviceCallback","prototype","__proto__","callService","request","callback","failedCallback","serviceCallId","idCounter","once","message","result","undefined","values","call","op","id","service","type","args","callOnConnection","advertise","on","_serviceResponse","bind","unadvertise","rosbridgeRequest","response","success","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileoverview\n * @author Brandon Alexander - baalexander@gmail.com\n */\n\nvar ServiceResponse = require('./ServiceResponse');\nvar ServiceRequest = require('./ServiceRequest');\nvar EventEmitter2 = require('eventemitter2').EventEmitter2;\n\n/**\n * A ROS service client.\n *\n * @constructor\n * @params options - possible keys include:\n *   * ros - the ROSLIB.Ros connection handle\n *   * name - the service name, like /add_two_ints\n *   * serviceType - the service type, like 'rospy_tutorials/AddTwoInts'\n */\nfunction Service(options) {\n  options = options || {};\n  this.ros = options.ros;\n  this.name = options.name;\n  this.serviceType = options.serviceType;\n  this.isAdvertised = false;\n\n  this._serviceCallback = null;\n}\nService.prototype.__proto__ = EventEmitter2.prototype;\n/**\n * Calls the service. Returns the service response in the\n * callback. Does nothing if this service is currently advertised.\n *\n * @param request - the ROSLIB.ServiceRequest to send\n * @param callback - function with params:\n *   * response - the response from the service request\n * @param failedCallback - the callback function when the service call failed (optional). Params:\n *   * error - the error message reported by ROS\n */\nService.prototype.callService = function(request, callback, failedCallback) {\n  if (this.isAdvertised) {\n    return;\n  }\n\n  var serviceCallId = 'call_service:' + this.name + ':' + (++this.ros.idCounter);\n\n  if (callback || failedCallback) {\n    this.ros.once(serviceCallId, function(message) {\n      if (message.result !== undefined && message.result === false) {\n        if (typeof failedCallback === 'function') {\n          failedCallback(message.values);\n        }\n      } else if (typeof callback === 'function') {\n        callback(new ServiceResponse(message.values));\n      }\n    });\n  }\n\n  var call = {\n    op : 'call_service',\n    id : serviceCallId,\n    service : this.name,\n    type: this.serviceType,\n    args : request\n  };\n  this.ros.callOnConnection(call);\n};\n\n/**\n * Advertise the service. This turns the Service object from a client\n * into a server. The callback will be called with every request\n * that's made on this service.\n *\n * @param callback - This works similarly to the callback for a C++ service and should take the following params:\n *   * request - the service request\n *   * response - an empty dictionary. Take care not to overwrite this. Instead, only modify the values within.\n *   It should return true if the service has finished successfully,\n *   i.e. without any fatal errors.\n */\nService.prototype.advertise = function(callback) {\n  if (this.isAdvertised || typeof callback !== 'function') {\n    return;\n  }\n\n  this._serviceCallback = callback;\n  this.ros.on(this.name, this._serviceResponse.bind(this));\n  this.ros.callOnConnection({\n    op: 'advertise_service',\n    type: this.serviceType,\n    service: this.name\n  });\n  this.isAdvertised = true;\n};\n\nService.prototype.unadvertise = function() {\n  if (!this.isAdvertised) {\n    return;\n  }\n  this.ros.callOnConnection({\n    op: 'unadvertise_service',\n    service: this.name\n  });\n  this.isAdvertised = false;\n};\n\nService.prototype._serviceResponse = function(rosbridgeRequest) {\n  var response = {};\n  var success = this._serviceCallback(rosbridgeRequest.args, response);\n\n  var call = {\n    op: 'service_response',\n    service: this.name,\n    values: new ServiceResponse(response),\n    result: success\n  };\n\n  if (rosbridgeRequest.id) {\n    call.id = rosbridgeRequest.id;\n  }\n\n  this.ros.callOnConnection(call);\n};\n\nmodule.exports = Service;\n"]},"metadata":{},"sourceType":"script"}