{"ast":null,"code":"/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;\n!function (undefined) {\n  var hasOwnProperty = Object.hasOwnProperty;\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n  var nextTickSupported = typeof process == 'object' && typeof process.nextTick == 'function';\n  var symbolsSupported = typeof Symbol === 'function';\n  var reflectSupported = typeof Reflect === 'object';\n  var setImmediateSupported = typeof setImmediate === 'function';\n\n  var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;\n\n  var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === 'function' ? Reflect.ownKeys : function (obj) {\n    var arr = Object.getOwnPropertyNames(obj);\n    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));\n    return arr;\n  } : Object.keys;\n\n  function init() {\n    this._events = {};\n\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n      conf.delimiter && (this.delimiter = conf.delimiter);\n\n      if (conf.maxListeners !== undefined) {\n        this._maxListeners = conf.maxListeners;\n      }\n\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this._newListener = conf.newListener);\n      conf.removeListener && (this._removeListener = conf.removeListener);\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\n      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function logPossibleMemoryLeak(count, eventName) {\n    var errorMsg = '(node) warning: possible EventEmitter memory ' + 'leak detected. ' + count + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.';\n\n    if (this.verboseMemoryLeak) {\n      errorMsg += ' Event name: ' + eventName + '.';\n    }\n\n    if (typeof process !== 'undefined' && process.emitWarning) {\n      var e = new Error(errorMsg);\n      e.name = 'MaxListenersExceededWarning';\n      e.emitter = this;\n      e.count = count;\n      process.emitWarning(e);\n    } else {\n      console.error(errorMsg);\n\n      if (console.trace) {\n        console.trace();\n      }\n    }\n  }\n\n  var toArray = function (a, b, c) {\n    var n = arguments.length;\n\n    switch (n) {\n      case 0:\n        return [];\n\n      case 1:\n        return [a];\n\n      case 2:\n        return [a, b];\n\n      case 3:\n        return [a, b, c];\n\n      default:\n        var arr = new Array(n);\n\n        while (n--) {\n          arr[n] = arguments[n];\n        }\n\n        return arr;\n    }\n  };\n\n  function toObject(keys, values) {\n    var obj = {};\n    var key;\n    var len = keys.length;\n    var valuesCount = values ? value.length : 0;\n\n    for (var i = 0; i < len; i++) {\n      key = keys[i];\n      obj[key] = i < valuesCount ? values[i] : undefined;\n    }\n\n    return obj;\n  }\n\n  function TargetObserver(emitter, target, options) {\n    this._emitter = emitter;\n    this._target = target;\n    this._listeners = {};\n    this._listenersCount = 0;\n    var on, off;\n\n    if (options.on || options.off) {\n      on = options.on;\n      off = options.off;\n    }\n\n    if (target.addEventListener) {\n      on = target.addEventListener;\n      off = target.removeEventListener;\n    } else if (target.addListener) {\n      on = target.addListener;\n      off = target.removeListener;\n    } else if (target.on) {\n      on = target.on;\n      off = target.off;\n    }\n\n    if (!on && !off) {\n      throw Error('target does not implement any known event API');\n    }\n\n    if (typeof on !== 'function') {\n      throw TypeError('on method must be a function');\n    }\n\n    if (typeof off !== 'function') {\n      throw TypeError('off method must be a function');\n    }\n\n    this._on = on;\n    this._off = off;\n    var _observers = emitter._observers;\n\n    if (_observers) {\n      _observers.push(this);\n    } else {\n      emitter._observers = [this];\n    }\n  }\n\n  Object.assign(TargetObserver.prototype, {\n    subscribe: function (event, localEvent, reducer) {\n      var observer = this;\n      var target = this._target;\n      var emitter = this._emitter;\n      var listeners = this._listeners;\n\n      var handler = function () {\n        var args = toArray.apply(null, arguments);\n        var eventObj = {\n          data: args,\n          name: localEvent,\n          original: event\n        };\n\n        if (reducer) {\n          var result = reducer.call(target, eventObj);\n\n          if (result !== false) {\n            emitter.emit.apply(emitter, [eventObj.name].concat(args));\n          }\n\n          return;\n        }\n\n        emitter.emit.apply(emitter, [localEvent].concat(args));\n      };\n\n      if (listeners[event]) {\n        throw Error('Event \\'' + event + '\\' is already listening');\n      }\n\n      this._listenersCount++;\n\n      if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {\n        this._onNewListener = function (_event) {\n          if (_event === localEvent && listeners[event] === null) {\n            listeners[event] = handler;\n\n            observer._on.call(target, event, handler);\n          }\n        };\n\n        emitter.on('newListener', this._onNewListener);\n\n        this._onRemoveListener = function (_event) {\n          if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {\n            listeners[event] = null;\n\n            observer._off.call(target, event, handler);\n          }\n        };\n\n        listeners[event] = null;\n        emitter.on('removeListener', this._onRemoveListener);\n      } else {\n        listeners[event] = handler;\n\n        observer._on.call(target, event, handler);\n      }\n    },\n    unsubscribe: function (event) {\n      var observer = this;\n      var listeners = this._listeners;\n      var emitter = this._emitter;\n      var handler;\n      var events;\n      var off = this._off;\n      var target = this._target;\n      var i;\n\n      if (event && typeof event !== 'string') {\n        throw TypeError('event must be a string');\n      }\n\n      function clearRefs() {\n        if (observer._onNewListener) {\n          emitter.off('newListener', observer._onNewListener);\n          emitter.off('removeListener', observer._onRemoveListener);\n          observer._onNewListener = null;\n          observer._onRemoveListener = null;\n        }\n\n        var index = findTargetIndex.call(emitter, observer);\n\n        emitter._observers.splice(index, 1);\n      }\n\n      if (event) {\n        handler = listeners[event];\n        if (!handler) return;\n        off.call(target, event, handler);\n        delete listeners[event];\n\n        if (! --this._listenersCount) {\n          clearRefs();\n        }\n      } else {\n        events = ownKeys(listeners);\n        i = events.length;\n\n        while (i-- > 0) {\n          event = events[i];\n          off.call(target, event, listeners[event]);\n        }\n\n        this._listeners = {};\n        this._listenersCount = 0;\n        clearRefs();\n      }\n    }\n  });\n\n  function resolveOptions(options, schema, reducers, allowUnknown) {\n    var computedOptions = Object.assign({}, schema);\n    if (!options) return computedOptions;\n\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object');\n    }\n\n    var keys = Object.keys(options);\n    var length = keys.length;\n    var option, value;\n    var reducer;\n\n    function reject(reason) {\n      throw Error('Invalid \"' + option + '\" option value' + (reason ? '. Reason: ' + reason : ''));\n    }\n\n    for (var i = 0; i < length; i++) {\n      option = keys[i];\n\n      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {\n        throw Error('Unknown \"' + option + '\" option');\n      }\n\n      value = options[option];\n\n      if (value !== undefined) {\n        reducer = reducers[option];\n        computedOptions[option] = reducer ? reducer(value, reject) : value;\n      }\n    }\n\n    return computedOptions;\n  }\n\n  function constructorReducer(value, reject) {\n    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {\n      reject('value must be a constructor');\n    }\n\n    return value;\n  }\n\n  function makeTypeReducer(types) {\n    var message = 'value must be type of ' + types.join('|');\n    var len = types.length;\n    var firstType = types[0];\n    var secondType = types[1];\n\n    if (len === 1) {\n      return function (v, reject) {\n        if (typeof v === firstType) {\n          return v;\n        }\n\n        reject(message);\n      };\n    }\n\n    if (len === 2) {\n      return function (v, reject) {\n        var kind = typeof v;\n        if (kind === firstType || kind === secondType) return v;\n        reject(message);\n      };\n    }\n\n    return function (v, reject) {\n      var kind = typeof v;\n      var i = len;\n\n      while (i-- > 0) {\n        if (kind === types[i]) return v;\n      }\n\n      reject(message);\n    };\n  }\n\n  var functionReducer = makeTypeReducer(['function']);\n  var objectFunctionReducer = makeTypeReducer(['object', 'function']);\n\n  function makeCancelablePromise(Promise, executor, options) {\n    var isCancelable;\n    var callbacks;\n    var timer = 0;\n    var subscriptionClosed;\n    var promise = new Promise(function (resolve, reject, onCancel) {\n      options = resolveOptions(options, {\n        timeout: 0,\n        overload: false\n      }, {\n        timeout: function (value, reject) {\n          value *= 1;\n\n          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {\n            reject('timeout must be a positive number');\n          }\n\n          return value;\n        }\n      });\n      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';\n\n      function cleanup() {\n        if (callbacks) {\n          callbacks = null;\n        }\n\n        if (timer) {\n          clearTimeout(timer);\n          timer = 0;\n        }\n      }\n\n      var _resolve = function (value) {\n        cleanup();\n        resolve(value);\n      };\n\n      var _reject = function (err) {\n        cleanup();\n        reject(err);\n      };\n\n      if (isCancelable) {\n        executor(_resolve, _reject, onCancel);\n      } else {\n        callbacks = [function (reason) {\n          _reject(reason || Error('canceled'));\n        }];\n        executor(_resolve, _reject, function (cb) {\n          if (subscriptionClosed) {\n            throw Error('Unable to subscribe on cancel event asynchronously');\n          }\n\n          if (typeof cb !== 'function') {\n            throw TypeError('onCancel callback must be a function');\n          }\n\n          callbacks.push(cb);\n        });\n        subscriptionClosed = true;\n      }\n\n      if (options.timeout > 0) {\n        timer = setTimeout(function () {\n          var reason = Error('timeout');\n          reason.code = 'ETIMEDOUT';\n          timer = 0;\n          promise.cancel(reason);\n          reject(reason);\n        }, options.timeout);\n      }\n    });\n\n    if (!isCancelable) {\n      promise.cancel = function (reason) {\n        if (!callbacks) {\n          return;\n        }\n\n        var length = callbacks.length;\n\n        for (var i = 1; i < length; i++) {\n          callbacks[i](reason);\n        } // internal callback to reject the promise\n\n\n        callbacks[0](reason);\n        callbacks = null;\n      };\n    }\n\n    return promise;\n  }\n\n  function findTargetIndex(observer) {\n    var observers = this._observers;\n\n    if (!observers) {\n      return -1;\n    }\n\n    var len = observers.length;\n\n    for (var i = 0; i < len; i++) {\n      if (observers[i]._target === observer) return i;\n    }\n\n    return -1;\n  } // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n\n\n  function searchListenerTree(handlers, type, tree, i, typeLength) {\n    if (!tree) {\n      return null;\n    }\n\n    if (i === 0) {\n      var kind = typeof type;\n\n      if (kind === 'string') {\n        var ns,\n            n,\n            l = 0,\n            j = 0,\n            delimiter = this.delimiter,\n            dl = delimiter.length;\n\n        if ((n = type.indexOf(delimiter)) !== -1) {\n          ns = new Array(5);\n\n          do {\n            ns[l++] = type.slice(j, n);\n            j = n + dl;\n          } while ((n = type.indexOf(delimiter, j)) !== -1);\n\n          ns[l++] = type.slice(j);\n          type = ns;\n          typeLength = l;\n        } else {\n          type = [type];\n          typeLength = 1;\n        }\n      } else if (kind === 'object') {\n        typeLength = type.length;\n      } else {\n        type = [type];\n        typeLength = 1;\n      }\n    }\n\n    var listeners = null,\n        branch,\n        xTree,\n        xxTree,\n        isolatedBranch,\n        endReached,\n        currentType = type[i],\n        nextType = type[i + 1],\n        branches,\n        _listeners;\n\n    if (i === typeLength) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (tree._listeners) {\n        if (typeof tree._listeners === 'function') {\n          handlers && handlers.push(tree._listeners);\n          listeners = [tree];\n        } else {\n          handlers && handlers.push.apply(handlers, tree._listeners);\n          listeners = [tree];\n        }\n      }\n    } else {\n      if (currentType === '*') {\n        //\n        // If the event emitted is '*' at this part\n        // or there is a concrete match at this patch\n        //\n        branches = ownKeys(tree);\n        n = branches.length;\n\n        while (n-- > 0) {\n          branch = branches[n];\n\n          if (branch !== '_listeners') {\n            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);\n\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === '*';\n\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);\n        }\n\n        branches = ownKeys(tree);\n        n = branches.length;\n\n        while (n-- > 0) {\n          branch = branches[n];\n\n          if (branch !== '_listeners') {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);\n\n                if (_listeners) {\n                  if (listeners) {\n                    listeners.push.apply(listeners, _listeners);\n                  } else {\n                    listeners = _listeners;\n                  }\n                }\n              }\n\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            } else if (branch === nextType) {\n              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            }\n\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n\n        return listeners;\n      } else if (tree[currentType]) {\n        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);\n      }\n    }\n\n    xTree = tree['*'];\n\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1, typeLength);\n    }\n\n    xxTree = tree['**'];\n\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n        } // Build arrays of matching next branches and others.\n\n\n        branches = ownKeys(xxTree);\n        n = branches.length;\n\n        while (n-- > 0) {\n          branch = branches[n];\n\n          if (branch !== '_listeners') {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {\n                '**': isolatedBranch\n              }, i + 1, typeLength);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener, prepend) {\n    var len = 0,\n        j = 0,\n        i,\n        delimiter = this.delimiter,\n        dl = delimiter.length,\n        ns;\n\n    if (typeof type === 'string') {\n      if ((i = type.indexOf(delimiter)) !== -1) {\n        ns = new Array(5);\n\n        do {\n          ns[len++] = type.slice(j, i);\n          j = i + dl;\n        } while ((i = type.indexOf(delimiter, j)) !== -1);\n\n        ns[len++] = type.slice(j);\n      } else {\n        ns = [type];\n        len = 1;\n      }\n    } else {\n      ns = type;\n      len = type.length;\n    } //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n\n\n    if (len > 1) {\n      for (i = 0; i + 1 < len; i++) {\n        if (ns[i] === '**' && ns[i + 1] === '**') {\n          return;\n        }\n      }\n    }\n\n    var tree = this.listenerTree,\n        name;\n\n    for (i = 0; i < len; i++) {\n      name = ns[i];\n      tree = tree[name] || (tree[name] = {});\n\n      if (i === len - 1) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else {\n          if (typeof tree._listeners === 'function') {\n            tree._listeners = [tree._listeners];\n          }\n\n          if (prepend) {\n            tree._listeners.unshift(listener);\n          } else {\n            tree._listeners.push(listener);\n          }\n\n          if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {\n            tree._listeners.warned = true;\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function collectTreeEvents(tree, events, root, asArray) {\n    var branches = ownKeys(tree);\n    var i = branches.length;\n    var branch, branchName, path;\n    var hasListeners = tree['_listeners'];\n    var isArrayPath;\n\n    while (i-- > 0) {\n      branchName = branches[i];\n      branch = tree[branchName];\n\n      if (branchName === '_listeners') {\n        path = root;\n      } else {\n        path = root ? root.concat(branchName) : [branchName];\n      }\n\n      isArrayPath = asArray || typeof branchName === 'symbol';\n      hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));\n\n      if (typeof branch === 'object') {\n        collectTreeEvents.call(this, branch, events, path, isArrayPath);\n      }\n    }\n\n    return events;\n  }\n\n  function recursivelyGarbageCollect(root) {\n    var keys = ownKeys(root);\n    var i = keys.length;\n    var obj, key, flag;\n\n    while (i-- > 0) {\n      key = keys[i];\n      obj = root[key];\n\n      if (obj) {\n        flag = true;\n\n        if (key !== '_listeners' && !recursivelyGarbageCollect(obj)) {\n          delete root[key];\n        }\n      }\n    }\n\n    return flag;\n  }\n\n  function Listener(emitter, event, listener) {\n    this.emitter = emitter;\n    this.event = event;\n    this.listener = listener;\n  }\n\n  Listener.prototype.off = function () {\n    this.emitter.off(this.event, this.listener);\n    return this;\n  };\n\n  function setupListener(event, listener, options) {\n    if (options === true) {\n      promisify = true;\n    } else if (options === false) {\n      async = true;\n    } else {\n      if (!options || typeof options !== 'object') {\n        throw TypeError('options should be an object or true');\n      }\n\n      var async = options.async;\n      var promisify = options.promisify;\n      var nextTick = options.nextTick;\n      var objectify = options.objectify;\n    }\n\n    if (async || nextTick || promisify) {\n      var _listener = listener;\n\n      var _origin = listener._origin || listener;\n\n      if (nextTick && !nextTickSupported) {\n        throw Error('process.nextTick is not supported');\n      }\n\n      if (promisify === undefined) {\n        promisify = listener.constructor.name === 'AsyncFunction';\n      }\n\n      listener = function () {\n        var args = arguments;\n        var context = this;\n        var event = this.event;\n        return promisify ? nextTick ? Promise.resolve() : new Promise(function (resolve) {\n          _setImmediate(resolve);\n        }).then(function () {\n          context.event = event;\n          return _listener.apply(context, args);\n        }) : (nextTick ? process.nextTick : _setImmediate)(function () {\n          context.event = event;\n\n          _listener.apply(context, args);\n        });\n      };\n\n      listener._async = true;\n      listener._origin = _origin;\n    }\n\n    return [listener, objectify ? new Listener(this, event, listener) : this];\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this._newListener = false;\n    this._removeListener = false;\n    this.verboseMemoryLeak = false;\n    configure.call(this, conf);\n  }\n\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n\n  EventEmitter.prototype.listenTo = function (target, events, options) {\n    if (typeof target !== 'object') {\n      throw TypeError('target musts be an object');\n    }\n\n    var emitter = this;\n    options = resolveOptions(options, {\n      on: undefined,\n      off: undefined,\n      reducers: undefined\n    }, {\n      on: functionReducer,\n      off: functionReducer,\n      reducers: objectFunctionReducer\n    });\n\n    function listen(events) {\n      if (typeof events !== 'object') {\n        throw TypeError('events must be an object');\n      }\n\n      var reducers = options.reducers;\n      var index = findTargetIndex.call(emitter, target);\n      var observer;\n\n      if (index === -1) {\n        observer = new TargetObserver(emitter, target, options);\n      } else {\n        observer = emitter._observers[index];\n      }\n\n      var keys = ownKeys(events);\n      var len = keys.length;\n      var event;\n      var isSingleReducer = typeof reducers === 'function';\n\n      for (var i = 0; i < len; i++) {\n        event = keys[i];\n        observer.subscribe(event, events[event] || event, isSingleReducer ? reducers : reducers && reducers[event]);\n      }\n    }\n\n    isArray(events) ? listen(toObject(events)) : typeof events === 'string' ? listen(toObject(events.split(/\\s+/))) : listen(events);\n    return this;\n  };\n\n  EventEmitter.prototype.stopListeningTo = function (target, event) {\n    var observers = this._observers;\n\n    if (!observers) {\n      return false;\n    }\n\n    var i = observers.length;\n    var observer;\n    var matched = false;\n\n    if (target && typeof target !== 'object') {\n      throw TypeError('target should be an object');\n    }\n\n    while (i-- > 0) {\n      observer = observers[i];\n\n      if (!target || observer._target === target) {\n        observer.unsubscribe(event);\n        matched = true;\n      }\n    }\n\n    return matched;\n  }; // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function (n) {\n    if (n !== undefined) {\n      this._maxListeners = n;\n      if (!this._conf) this._conf = {};\n      this._conf.maxListeners = n;\n    }\n  };\n\n  EventEmitter.prototype.getMaxListeners = function () {\n    return this._maxListeners;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function (event, fn, options) {\n    return this._once(event, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependOnceListener = function (event, fn, options) {\n    return this._once(event, fn, true, options);\n  };\n\n  EventEmitter.prototype._once = function (event, fn, prepend, options) {\n    return this._many(event, 1, fn, prepend, options);\n  };\n\n  EventEmitter.prototype.many = function (event, ttl, fn, options) {\n    return this._many(event, ttl, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependMany = function (event, ttl, fn, options) {\n    return this._many(event, ttl, fn, true, options);\n  };\n\n  EventEmitter.prototype._many = function (event, ttl, fn, prepend, options) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n\n      return fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n    return this._on(event, listener, prepend, options);\n  };\n\n  EventEmitter.prototype.emit = function () {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n    var type = arguments[0],\n        ns,\n        wildcard = this.wildcard;\n    var args, l, i, j, containsSymbol;\n\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n\n    if (wildcard) {\n      ns = type;\n\n      if (type !== 'newListener' && type !== 'removeListener') {\n        if (typeof type === 'object') {\n          l = type.length;\n\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all && this._all.length) {\n      handler = this._all.slice();\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n\n        switch (al) {\n          case 1:\n            handler[i].call(this, type);\n            break;\n\n          case 2:\n            handler[i].call(this, type, arguments[1]);\n            break;\n\n          case 3:\n            handler[i].call(this, type, arguments[1], arguments[2]);\n            break;\n\n          default:\n            handler[i].apply(this, arguments);\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);\n    } else {\n      handler = this._events[type];\n\n      if (typeof handler === 'function') {\n        this.event = type;\n\n        switch (al) {\n          case 1:\n            handler.call(this);\n            break;\n\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n\n          default:\n            args = new Array(al - 1);\n\n            for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n\n            handler.apply(this, args);\n        }\n\n        return true;\n      } else if (handler) {\n        // need to make copy of handlers because list can change in the middle\n        // of emit call\n        handler = handler.slice();\n      }\n    }\n\n    if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n\n        switch (al) {\n          case 1:\n            handler[i].call(this);\n            break;\n\n          case 2:\n            handler[i].call(this, arguments[1]);\n            break;\n\n          case 3:\n            handler[i].call(this, arguments[1], arguments[2]);\n            break;\n\n          default:\n            handler[i].apply(this, args);\n        }\n      }\n\n      return true;\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return !!this._all;\n  };\n\n  EventEmitter.prototype.emitAsync = function () {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n    var type = arguments[0],\n        wildcard = this.wildcard,\n        ns,\n        containsSymbol;\n    var args, l, i, j;\n\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return Promise.resolve([false]);\n      }\n    }\n\n    if (wildcard) {\n      ns = type;\n\n      if (type !== 'newListener' && type !== 'removeListener') {\n        if (typeof type === 'object') {\n          l = type.length;\n\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var promises = [];\n    var al = arguments.length;\n    var handler;\n\n    if (this._all) {\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n\n        switch (al) {\n          case 1:\n            promises.push(this._all[i].call(this, type));\n            break;\n\n          case 2:\n            promises.push(this._all[i].call(this, type, arguments[1]));\n            break;\n\n          case 3:\n            promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n            break;\n\n          default:\n            promises.push(this._all[i].apply(this, arguments));\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n\n      switch (al) {\n        case 1:\n          promises.push(handler.call(this));\n          break;\n\n        case 2:\n          promises.push(handler.call(this, arguments[1]));\n          break;\n\n        case 3:\n          promises.push(handler.call(this, arguments[1], arguments[2]));\n          break;\n\n        default:\n          args = new Array(al - 1);\n\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n\n          promises.push(handler.apply(this, args));\n      }\n    } else if (handler && handler.length) {\n      handler = handler.slice();\n\n      if (al > 3) {\n        args = new Array(al - 1);\n\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n\n        switch (al) {\n          case 1:\n            promises.push(handler[i].call(this));\n            break;\n\n          case 2:\n            promises.push(handler[i].call(this, arguments[1]));\n            break;\n\n          case 3:\n            promises.push(handler[i].call(this, arguments[1], arguments[2]));\n            break;\n\n          default:\n            promises.push(handler[i].apply(this, args));\n        }\n      }\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\n      } else {\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return Promise.all(promises);\n  };\n\n  EventEmitter.prototype.on = function (type, listener, options) {\n    return this._on(type, listener, false, options);\n  };\n\n  EventEmitter.prototype.prependListener = function (type, listener, options) {\n    return this._on(type, listener, true, options);\n  };\n\n  EventEmitter.prototype.onAny = function (fn) {\n    return this._onAny(fn, false);\n  };\n\n  EventEmitter.prototype.prependAny = function (fn) {\n    return this._onAny(fn, true);\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype._onAny = function (fn, prepend) {\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if (!this._all) {\n      this._all = [];\n    } // Add the function to the event listener collection.\n\n\n    if (prepend) {\n      this._all.unshift(fn);\n    } else {\n      this._all.push(fn);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype._on = function (type, listener, prepend, options) {\n    if (typeof type === 'function') {\n      this._onAny(type, listener);\n\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n\n    this._events || init.call(this);\n    var returnValue = this,\n        temp;\n\n    if (options !== undefined) {\n      temp = setupListener.call(this, type, listener, options);\n      listener = temp[0];\n      returnValue = temp[1];\n    } // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n\n\n    if (this._newListener) {\n      this.emit('newListener', type, listener);\n    }\n\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener, prepend);\n      return returnValue;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else {\n      if (typeof this._events[type] === 'function') {\n        // Change to array.\n        this._events[type] = [this._events[type]];\n      } // If we've already got an array, just add\n\n\n      if (prepend) {\n        this._events[type].unshift(listener);\n      } else {\n        this._events[type].push(listener);\n      } // Check for listener leak\n\n\n      if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {\n        this._events[type].warned = true;\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\n      }\n    }\n\n    return returnValue;\n  };\n\n  EventEmitter.prototype.off = function (type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,\n        leafs = [];\n\n    if (this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n      if (!leafs) return this;\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({\n        _listeners: handlers\n      });\n    }\n\n    for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n\n      if (isArray(handlers)) {\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if (this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        } else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if (this.wildcard) {\n            delete leaf._listeners;\n          } else {\n            delete this._events[type];\n          }\n        }\n\n        if (this._removeListener) this.emit(\"removeListener\", type, listener);\n        return this;\n      } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {\n        if (this.wildcard) {\n          delete leaf._listeners;\n        } else {\n          delete this._events[type];\n        }\n\n        if (this._removeListener) this.emit(\"removeListener\", type, listener);\n      }\n    }\n\n    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function (fn) {\n    var i = 0,\n        l = 0,\n        fns;\n\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n\n      for (i = 0, l = fns.length; i < l; i++) {\n        if (fn === fns[i]) {\n          fns.splice(i, 1);\n          if (this._removeListener) this.emit(\"removeListenerAny\", fn);\n          return this;\n        }\n      }\n    } else {\n      fns = this._all;\n\n      if (this._removeListener) {\n        for (i = 0, l = fns.length; i < l; i++) this.emit(\"removeListenerAny\", fns[i]);\n      }\n\n      this._all = [];\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (type === undefined) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if (this.wildcard) {\n      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0),\n          leaf,\n          i;\n      if (!leafs) return this;\n\n      for (i = 0; i < leafs.length; i++) {\n        leaf = leafs[i];\n        leaf._listeners = null;\n      }\n\n      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    } else if (this._events) {\n      this._events[type] = null;\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function (type) {\n    var _events = this._events;\n    var keys, listeners, allListeners;\n    var i;\n    var listenerTree;\n\n    if (type === undefined) {\n      if (this.wildcard) {\n        throw Error('event name required for wildcard emitter');\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      keys = ownKeys(_events);\n      i = keys.length;\n      allListeners = [];\n\n      while (i-- > 0) {\n        listeners = _events[keys[i]];\n\n        if (typeof listeners === 'function') {\n          allListeners.push(listeners);\n        } else {\n          allListeners.push.apply(allListeners, listeners);\n        }\n      }\n\n      return allListeners;\n    } else {\n      if (this.wildcard) {\n        listenerTree = this.listenerTree;\n        if (!listenerTree) return [];\n        var handlers = [];\n        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n        searchListenerTree.call(this, handlers, ns, listenerTree, 0);\n        return handlers;\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      listeners = _events[type];\n\n      if (!listeners) {\n        return [];\n      }\n\n      return typeof listeners === 'function' ? [listeners] : listeners;\n    }\n  };\n\n  EventEmitter.prototype.eventNames = function (nsAsArray) {\n    var _events = this._events;\n    return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];\n  };\n\n  EventEmitter.prototype.listenerCount = function (type) {\n    return this.listeners(type).length;\n  };\n\n  EventEmitter.prototype.hasListeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers.length > 0;\n    }\n\n    var _events = this._events;\n    var _all = this._all;\n    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));\n  };\n\n  EventEmitter.prototype.listenersAny = function () {\n    if (this._all) {\n      return this._all;\n    } else {\n      return [];\n    }\n  };\n\n  EventEmitter.prototype.waitFor = function (event, options) {\n    var self = this;\n    var type = typeof options;\n\n    if (type === 'number') {\n      options = {\n        timeout: options\n      };\n    } else if (type === 'function') {\n      options = {\n        filter: options\n      };\n    }\n\n    options = resolveOptions(options, {\n      timeout: 0,\n      filter: undefined,\n      handleError: false,\n      Promise: Promise,\n      overload: false\n    }, {\n      filter: functionReducer,\n      Promise: constructorReducer\n    });\n    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {\n      function listener() {\n        var filter = options.filter;\n\n        if (filter && !filter.apply(self, arguments)) {\n          return;\n        }\n\n        self.off(event, listener);\n\n        if (options.handleError) {\n          var err = arguments[0];\n          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));\n        } else {\n          resolve(toArray.apply(null, arguments));\n        }\n      }\n\n      onCancel(function () {\n        self.off(event, listener);\n      });\n\n      self._on(event, listener, false);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  };\n\n  function once(emitter, name, options) {\n    options = resolveOptions(options, {\n      Promise: Promise,\n      timeout: 0,\n      overload: false\n    }, {\n      Promise: constructorReducer\n    });\n    var _Promise = options.Promise;\n    return makeCancelablePromise(_Promise, function (resolve, reject, onCancel) {\n      var handler;\n\n      if (typeof emitter.addEventListener === 'function') {\n        handler = function () {\n          resolve(toArray.apply(null, arguments));\n        };\n\n        onCancel(function () {\n          emitter.removeEventListener(name, handler);\n        });\n        emitter.addEventListener(name, handler, {\n          once: true\n        });\n        return;\n      }\n\n      var eventListener = function () {\n        errorListener && emitter.removeListener('error', errorListener);\n        resolve(toArray.apply(null, arguments));\n      };\n\n      var errorListener;\n\n      if (name !== 'error') {\n        errorListener = function (err) {\n          emitter.removeListener(name, eventListener);\n          reject(err);\n        };\n\n        emitter.once('error', errorListener);\n      }\n\n      onCancel(function () {\n        errorListener && emitter.removeListener('error', errorListener);\n        emitter.removeListener(name, eventListener);\n      });\n      emitter.once(name, eventListener);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  }\n\n  var prototype = EventEmitter.prototype;\n  Object.defineProperties(EventEmitter, {\n    defaultMaxListeners: {\n      get: function () {\n        return prototype._maxListeners;\n      },\n      set: function (n) {\n        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n          throw TypeError('n must be a non-negative number');\n        }\n\n        prototype._maxListeners = n;\n      },\n      enumerable: true\n    },\n    once: {\n      value: once,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperties(prototype, {\n    _maxListeners: {\n      value: defaultMaxListeners,\n      writable: true,\n      configurable: true\n    },\n    _observers: {\n      value: null,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(function () {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = EventEmitter;\n  } else {\n    // global for any kind of environment.\n    var _global = new Function('', 'return this')();\n\n    _global.EventEmitter2 = EventEmitter;\n  }\n}();","map":{"version":3,"sources":["/Users/julien/Sites/react-ros-robot/node_modules/eventemitter2/lib/eventemitter2.js"],"names":["undefined","hasOwnProperty","Object","isArray","Array","_isArray","obj","prototype","toString","call","defaultMaxListeners","nextTickSupported","process","nextTick","symbolsSupported","Symbol","reflectSupported","Reflect","setImmediateSupported","setImmediate","_setImmediate","setTimeout","ownKeys","arr","getOwnPropertyNames","push","apply","getOwnPropertySymbols","keys","init","_events","_conf","configure","conf","delimiter","maxListeners","_maxListeners","wildcard","newListener","_newListener","removeListener","_removeListener","verboseMemoryLeak","ignoreErrors","listenerTree","logPossibleMemoryLeak","count","eventName","errorMsg","emitWarning","e","Error","name","emitter","console","error","trace","toArray","a","b","c","n","arguments","length","toObject","values","key","len","valuesCount","value","i","TargetObserver","target","options","_emitter","_target","_listeners","_listenersCount","on","off","addEventListener","removeEventListener","addListener","TypeError","_on","_off","_observers","assign","subscribe","event","localEvent","reducer","observer","listeners","handler","args","eventObj","data","original","result","emit","concat","_onNewListener","_event","_onRemoveListener","hasListeners","unsubscribe","events","clearRefs","index","findTargetIndex","splice","resolveOptions","schema","reducers","allowUnknown","computedOptions","option","reject","reason","constructorReducer","makeTypeReducer","types","message","join","firstType","secondType","v","kind","functionReducer","objectFunctionReducer","makeCancelablePromise","Promise","executor","isCancelable","callbacks","timer","subscriptionClosed","promise","resolve","onCancel","timeout","overload","Number","isFinite","cancel","cleanup","clearTimeout","_resolve","_reject","err","cb","code","observers","searchListenerTree","handlers","type","tree","typeLength","ns","l","j","dl","indexOf","slice","branch","xTree","xxTree","isolatedBranch","endReached","currentType","nextType","branches","growListenerTree","listener","prepend","unshift","warned","collectTreeEvents","root","asArray","branchName","path","isArrayPath","recursivelyGarbageCollect","flag","Listener","setupListener","promisify","async","objectify","_listener","_origin","constructor","context","then","_async","EventEmitter","EventEmitter2","listenTo","listen","isSingleReducer","split","stopListeningTo","matched","setMaxListeners","getMaxListeners","once","fn","_once","prependOnceListener","_many","many","ttl","prependMany","self","_all","containsSymbol","al","emitAsync","promises","all","prependListener","onAny","_onAny","prependAny","returnValue","temp","leafs","iLeaf","leaf","position","offAny","fns","removeAllListeners","allListeners","eventNames","nsAsArray","listenerCount","listenersAny","waitFor","filter","handleError","_Promise","eventListener","errorListener","defineProperties","get","set","isNaN","enumerable","writable","configurable","define","amd","exports","module","_global","Function"],"mappings":"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","sourcesContent":["/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n  var hasOwnProperty= Object.hasOwnProperty;\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n  var nextTickSupported= typeof process=='object' && typeof process.nextTick=='function';\n  var symbolsSupported= typeof Symbol==='function';\n  var reflectSupported= typeof Reflect === 'object';\n  var setImmediateSupported= typeof setImmediate === 'function';\n  var _setImmediate= setImmediateSupported ? setImmediate : setTimeout;\n  var ownKeys= symbolsSupported? (reflectSupported && typeof Reflect.ownKeys==='function'? Reflect.ownKeys : function(obj){\n    var arr= Object.getOwnPropertyNames(obj);\n    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));\n    return arr;\n  }) : Object.keys;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n\n      if(conf.maxListeners!==undefined){\n          this._maxListeners= conf.maxListeners;\n      }\n\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this._newListener = conf.newListener);\n      conf.removeListener && (this._removeListener = conf.removeListener);\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\n      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function logPossibleMemoryLeak(count, eventName) {\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\n        'leak detected. ' + count + ' listeners added. ' +\n        'Use emitter.setMaxListeners() to increase limit.';\n\n    if(this.verboseMemoryLeak){\n      errorMsg += ' Event name: ' + eventName + '.';\n    }\n\n    if(typeof process !== 'undefined' && process.emitWarning){\n      var e = new Error(errorMsg);\n      e.name = 'MaxListenersExceededWarning';\n      e.emitter = this;\n      e.count = count;\n      process.emitWarning(e);\n    } else {\n      console.error(errorMsg);\n\n      if (console.trace){\n        console.trace();\n      }\n    }\n  }\n\n  var toArray = function (a, b, c) {\n    var n = arguments.length;\n    switch (n) {\n      case 0:\n        return [];\n      case 1:\n        return [a];\n      case 2:\n        return [a, b];\n      case 3:\n        return [a, b, c];\n      default:\n        var arr = new Array(n);\n        while (n--) {\n          arr[n] = arguments[n];\n        }\n        return arr;\n    }\n  };\n\n  function toObject(keys, values) {\n    var obj = {};\n    var key;\n    var len = keys.length;\n    var valuesCount = values ? value.length : 0;\n    for (var i = 0; i < len; i++) {\n      key = keys[i];\n      obj[key] = i < valuesCount ? values[i] : undefined;\n    }\n    return obj;\n  }\n\n  function TargetObserver(emitter, target, options) {\n    this._emitter = emitter;\n    this._target = target;\n    this._listeners = {};\n    this._listenersCount = 0;\n\n    var on, off;\n\n    if (options.on || options.off) {\n      on = options.on;\n      off = options.off;\n    }\n\n    if (target.addEventListener) {\n      on = target.addEventListener;\n      off = target.removeEventListener;\n    } else if (target.addListener) {\n      on = target.addListener;\n      off = target.removeListener;\n    } else if (target.on) {\n      on = target.on;\n      off = target.off;\n    }\n\n    if (!on && !off) {\n      throw Error('target does not implement any known event API');\n    }\n\n    if (typeof on !== 'function') {\n      throw TypeError('on method must be a function');\n    }\n\n    if (typeof off !== 'function') {\n      throw TypeError('off method must be a function');\n    }\n\n    this._on = on;\n    this._off = off;\n\n    var _observers= emitter._observers;\n    if(_observers){\n      _observers.push(this);\n    }else{\n      emitter._observers= [this];\n    }\n  }\n\n  Object.assign(TargetObserver.prototype, {\n    subscribe: function(event, localEvent, reducer){\n      var observer= this;\n      var target= this._target;\n      var emitter= this._emitter;\n      var listeners= this._listeners;\n      var handler= function(){\n        var args= toArray.apply(null, arguments);\n        var eventObj= {\n          data: args,\n          name: localEvent,\n          original: event\n        };\n        if(reducer){\n          var result= reducer.call(target, eventObj);\n          if(result!==false){\n            emitter.emit.apply(emitter, [eventObj.name].concat(args))\n          }\n          return;\n        }\n        emitter.emit.apply(emitter, [localEvent].concat(args));\n      };\n\n\n      if(listeners[event]){\n        throw Error('Event \\'' + event + '\\' is already listening');\n      }\n\n      this._listenersCount++;\n\n      if(emitter._newListener && emitter._removeListener && !observer._onNewListener){\n\n        this._onNewListener = function (_event) {\n          if (_event === localEvent && listeners[event] === null) {\n            listeners[event] = handler;\n            observer._on.call(target, event, handler);\n          }\n        };\n\n        emitter.on('newListener', this._onNewListener);\n\n        this._onRemoveListener= function(_event){\n          if(_event === localEvent && !emitter.hasListeners(_event) && listeners[event]){\n            listeners[event]= null;\n            observer._off.call(target, event, handler);\n          }\n        };\n\n        listeners[event]= null;\n\n        emitter.on('removeListener', this._onRemoveListener);\n      }else{\n        listeners[event]= handler;\n        observer._on.call(target, event, handler);\n      }\n    },\n\n    unsubscribe: function(event){\n      var observer= this;\n      var listeners= this._listeners;\n      var emitter= this._emitter;\n      var handler;\n      var events;\n      var off= this._off;\n      var target= this._target;\n      var i;\n\n      if(event && typeof event!=='string'){\n        throw TypeError('event must be a string');\n      }\n\n      function clearRefs(){\n        if(observer._onNewListener){\n          emitter.off('newListener', observer._onNewListener);\n          emitter.off('removeListener', observer._onRemoveListener);\n          observer._onNewListener= null;\n          observer._onRemoveListener= null;\n        }\n        var index= findTargetIndex.call(emitter, observer);\n        emitter._observers.splice(index, 1);\n      }\n\n      if(event){\n        handler= listeners[event];\n        if(!handler) return;\n        off.call(target, event, handler);\n        delete listeners[event];\n        if(!--this._listenersCount){\n          clearRefs();\n        }\n      }else{\n        events= ownKeys(listeners);\n        i= events.length;\n        while(i-->0){\n          event= events[i];\n          off.call(target, event, listeners[event]);\n        }\n        this._listeners= {};\n        this._listenersCount= 0;\n        clearRefs();\n      }\n    }\n  });\n\n  function resolveOptions(options, schema, reducers, allowUnknown) {\n    var computedOptions = Object.assign({}, schema);\n\n    if (!options) return computedOptions;\n\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object')\n    }\n\n    var keys = Object.keys(options);\n    var length = keys.length;\n    var option, value;\n    var reducer;\n\n    function reject(reason) {\n      throw Error('Invalid \"' + option + '\" option value' + (reason ? '. Reason: ' + reason : ''))\n    }\n\n    for (var i = 0; i < length; i++) {\n      option = keys[i];\n      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {\n        throw Error('Unknown \"' + option + '\" option');\n      }\n      value = options[option];\n      if (value !== undefined) {\n        reducer = reducers[option];\n        computedOptions[option] = reducer ? reducer(value, reject) : value;\n      }\n    }\n    return computedOptions;\n  }\n\n  function constructorReducer(value, reject) {\n    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {\n      reject('value must be a constructor');\n    }\n    return value;\n  }\n\n  function makeTypeReducer(types) {\n    var message= 'value must be type of ' + types.join('|');\n    var len= types.length;\n    var firstType= types[0];\n    var secondType= types[1];\n\n    if (len === 1) {\n      return function (v, reject) {\n        if (typeof v === firstType) {\n          return v;\n        }\n        reject(message);\n      }\n    }\n\n    if (len === 2) {\n      return function (v, reject) {\n        var kind= typeof v;\n        if (kind === firstType || kind === secondType) return v;\n        reject(message);\n      }\n    }\n\n    return function (v, reject) {\n      var kind = typeof v;\n      var i = len;\n      while (i-- > 0) {\n        if (kind === types[i]) return v;\n      }\n      reject(message);\n    }\n  }\n\n  var functionReducer= makeTypeReducer(['function']);\n\n  var objectFunctionReducer= makeTypeReducer(['object', 'function']);\n\n  function makeCancelablePromise(Promise, executor, options) {\n    var isCancelable;\n    var callbacks;\n    var timer= 0;\n    var subscriptionClosed;\n\n    var promise = new Promise(function (resolve, reject, onCancel) {\n      options= resolveOptions(options, {\n        timeout: 0,\n        overload: false\n      }, {\n        timeout: function(value, reject){\n          value*= 1;\n          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {\n            reject('timeout must be a positive number');\n          }\n          return value;\n        }\n      });\n\n      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';\n\n      function cleanup() {\n        if (callbacks) {\n          callbacks = null;\n        }\n        if (timer) {\n          clearTimeout(timer);\n          timer = 0;\n        }\n      }\n\n      var _resolve= function(value){\n        cleanup();\n        resolve(value);\n      };\n\n      var _reject= function(err){\n        cleanup();\n        reject(err);\n      };\n\n      if (isCancelable) {\n        executor(_resolve, _reject, onCancel);\n      } else {\n        callbacks = [function(reason){\n          _reject(reason || Error('canceled'));\n        }];\n        executor(_resolve, _reject, function (cb) {\n          if (subscriptionClosed) {\n            throw Error('Unable to subscribe on cancel event asynchronously')\n          }\n          if (typeof cb !== 'function') {\n            throw TypeError('onCancel callback must be a function');\n          }\n          callbacks.push(cb);\n        });\n        subscriptionClosed= true;\n      }\n\n      if (options.timeout > 0) {\n        timer= setTimeout(function(){\n          var reason= Error('timeout');\n          reason.code = 'ETIMEDOUT'\n          timer= 0;\n          promise.cancel(reason);\n          reject(reason);\n        }, options.timeout);\n      }\n    });\n\n    if (!isCancelable) {\n      promise.cancel = function (reason) {\n        if (!callbacks) {\n          return;\n        }\n        var length = callbacks.length;\n        for (var i = 1; i < length; i++) {\n          callbacks[i](reason);\n        }\n        // internal callback to reject the promise\n        callbacks[0](reason);\n        callbacks = null;\n      };\n    }\n\n    return promise;\n  }\n\n  function findTargetIndex(observer) {\n    var observers = this._observers;\n    if(!observers){\n      return -1;\n    }\n    var len = observers.length;\n    for (var i = 0; i < len; i++) {\n      if (observers[i]._target === observer) return i;\n    }\n    return -1;\n  }\n\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i, typeLength) {\n    if (!tree) {\n      return null;\n    }\n\n    if (i === 0) {\n      var kind = typeof type;\n      if (kind === 'string') {\n        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;\n        if ((n = type.indexOf(delimiter)) !== -1) {\n          ns = new Array(5);\n          do {\n            ns[l++] = type.slice(j, n);\n            j = n + dl;\n          } while ((n = type.indexOf(delimiter, j)) !== -1);\n\n          ns[l++] = type.slice(j);\n          type = ns;\n          typeLength = l;\n        } else {\n          type = [type];\n          typeLength = 1;\n        }\n      } else if (kind === 'object') {\n        typeLength = type.length;\n      } else {\n        type = [type];\n        typeLength = 1;\n      }\n    }\n\n    var listeners= null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i],\n        nextType = type[i + 1], branches, _listeners;\n\n    if (i === typeLength) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n\n      if(tree._listeners) {\n        if (typeof tree._listeners === 'function') {\n          handlers && handlers.push(tree._listeners);\n          listeners = [tree];\n        } else {\n          handlers && handlers.push.apply(handlers, tree._listeners);\n          listeners = [tree];\n        }\n      }\n    } else {\n\n      if (currentType === '*') {\n        //\n        // If the event emitted is '*' at this part\n        // or there is a concrete match at this patch\n        //\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = (i + 1 === typeLength || (i + 2 === typeLength && nextType === '*'));\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);\n        }\n\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);\n                if (_listeners) {\n                  if (listeners) {\n                    listeners.push.apply(listeners, _listeners);\n                  } else {\n                    listeners = _listeners;\n                  }\n                }\n              }\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            } else if (branch === nextType) {\n              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            }\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (tree[currentType]) {\n        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);\n      }\n    }\n\n      xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1, typeLength);\n    }\n\n    xxTree = tree['**'];\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        branches= ownKeys(xxTree);\n        n= branches.length;\n        while(n-->0){\n          branch= branches[n];\n          if (branch !== '_listeners') {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {'**': isolatedBranch}, i + 1, typeLength);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener, prepend) {\n    var len = 0, j = 0, i, delimiter = this.delimiter, dl= delimiter.length, ns;\n\n    if(typeof type==='string') {\n      if ((i = type.indexOf(delimiter)) !== -1) {\n        ns = new Array(5);\n        do {\n          ns[len++] = type.slice(j, i);\n          j = i + dl;\n        } while ((i = type.indexOf(delimiter, j)) !== -1);\n\n        ns[len++] = type.slice(j);\n      }else{\n        ns= [type];\n        len= 1;\n      }\n    }else{\n      ns= type;\n      len= type.length;\n    }\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    if (len > 1) {\n      for (i = 0; i + 1 < len; i++) {\n        if (ns[i] === '**' && ns[i + 1] === '**') {\n          return;\n        }\n      }\n    }\n\n\n\n    var tree = this.listenerTree, name;\n\n    for (i = 0; i < len; i++) {\n      name = ns[i];\n\n      tree = tree[name] || (tree[name] = {});\n\n      if (i === len - 1) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else {\n          if (typeof tree._listeners === 'function') {\n            tree._listeners = [tree._listeners];\n          }\n\n          if (prepend) {\n            tree._listeners.unshift(listener);\n          } else {\n            tree._listeners.push(listener);\n          }\n\n          if (\n              !tree._listeners.warned &&\n              this._maxListeners > 0 &&\n              tree._listeners.length > this._maxListeners\n          ) {\n            tree._listeners.warned = true;\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\n          }\n        }\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function collectTreeEvents(tree, events, root, asArray){\n     var branches= ownKeys(tree);\n     var i= branches.length;\n     var branch, branchName, path;\n     var hasListeners= tree['_listeners'];\n     var isArrayPath;\n\n     while(i-->0){\n         branchName= branches[i];\n\n         branch= tree[branchName];\n\n         if(branchName==='_listeners'){\n             path= root;\n         }else {\n             path = root ? root.concat(branchName) : [branchName];\n         }\n\n         isArrayPath= asArray || typeof branchName==='symbol';\n\n         hasListeners && events.push(isArrayPath? path : path.join(this.delimiter));\n\n         if(typeof branch==='object'){\n             collectTreeEvents.call(this, branch, events, path, isArrayPath);\n         }\n     }\n\n     return events;\n  }\n\n  function recursivelyGarbageCollect(root) {\n    var keys = ownKeys(root);\n    var i= keys.length;\n    var obj, key, flag;\n    while(i-->0){\n      key = keys[i];\n      obj = root[key];\n\n      if(obj){\n          flag= true;\n          if(key !== '_listeners' && !recursivelyGarbageCollect(obj)){\n             delete root[key];\n          }\n      }\n    }\n\n    return flag;\n  }\n\n  function Listener(emitter, event, listener){\n    this.emitter= emitter;\n    this.event= event;\n    this.listener= listener;\n  }\n\n  Listener.prototype.off= function(){\n    this.emitter.off(this.event, this.listener);\n    return this;\n  };\n\n  function setupListener(event, listener, options){\n      if (options === true) {\n        promisify = true;\n      } else if (options === false) {\n        async = true;\n      } else {\n        if (!options || typeof options !== 'object') {\n          throw TypeError('options should be an object or true');\n        }\n        var async = options.async;\n        var promisify = options.promisify;\n        var nextTick = options.nextTick;\n        var objectify = options.objectify;\n      }\n\n      if (async || nextTick || promisify) {\n        var _listener = listener;\n        var _origin = listener._origin || listener;\n\n        if (nextTick && !nextTickSupported) {\n          throw Error('process.nextTick is not supported');\n        }\n\n        if (promisify === undefined) {\n          promisify = listener.constructor.name === 'AsyncFunction';\n        }\n\n        listener = function () {\n          var args = arguments;\n          var context = this;\n          var event = this.event;\n\n          return promisify ? (nextTick ? Promise.resolve() : new Promise(function (resolve) {\n            _setImmediate(resolve);\n          }).then(function () {\n            context.event = event;\n            return _listener.apply(context, args)\n          })) : (nextTick ? process.nextTick : _setImmediate)(function () {\n            context.event = event;\n            _listener.apply(context, args)\n          });\n        };\n\n        listener._async = true;\n        listener._origin = _origin;\n      }\n\n    return [listener, objectify? new Listener(this, event, listener): this];\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this._newListener = false;\n    this._removeListener = false;\n    this.verboseMemoryLeak = false;\n    configure.call(this, conf);\n  }\n\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n\n  EventEmitter.prototype.listenTo= function(target, events, options){\n    if(typeof target!=='object'){\n      throw TypeError('target musts be an object');\n    }\n\n    var emitter= this;\n\n    options = resolveOptions(options, {\n      on: undefined,\n      off: undefined,\n      reducers: undefined\n    }, {\n      on: functionReducer,\n      off: functionReducer,\n      reducers: objectFunctionReducer\n    });\n\n    function listen(events){\n      if(typeof events!=='object'){\n        throw TypeError('events must be an object');\n      }\n\n      var reducers= options.reducers;\n      var index= findTargetIndex.call(emitter, target);\n      var observer;\n\n      if(index===-1){\n        observer= new TargetObserver(emitter, target, options);\n      }else{\n        observer= emitter._observers[index];\n      }\n\n      var keys= ownKeys(events);\n      var len= keys.length;\n      var event;\n      var isSingleReducer= typeof reducers==='function';\n\n      for(var i=0; i<len; i++){\n        event= keys[i];\n        observer.subscribe(\n            event,\n            events[event] || event,\n            isSingleReducer ? reducers : reducers && reducers[event]\n        );\n      }\n    }\n\n    isArray(events)?\n        listen(toObject(events)) :\n        (typeof events==='string'? listen(toObject(events.split(/\\s+/))): listen(events));\n\n    return this;\n  };\n\n  EventEmitter.prototype.stopListeningTo = function (target, event) {\n    var observers = this._observers;\n\n    if(!observers){\n      return false;\n    }\n\n    var i = observers.length;\n    var observer;\n    var matched= false;\n\n    if(target && typeof target!=='object'){\n      throw TypeError('target should be an object');\n    }\n\n    while (i-- > 0) {\n      observer = observers[i];\n      if (!target || observer._target === target) {\n        observer.unsubscribe(event);\n        matched= true;\n      }\n    }\n\n    return matched;\n  };\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    if (n !== undefined) {\n      this._maxListeners = n;\n      if (!this._conf) this._conf = {};\n      this._conf.maxListeners = n;\n    }\n  };\n\n  EventEmitter.prototype.getMaxListeners = function() {\n    return this._maxListeners;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn, options) {\n    return this._once(event, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependOnceListener = function(event, fn, options) {\n    return this._once(event, fn, true, options);\n  };\n\n  EventEmitter.prototype._once = function(event, fn, prepend, options) {\n    return this._many(event, 1, fn, prepend, options);\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, true, options);\n  };\n\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      return fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    return this._on(event, listener, prepend, options);\n  };\n\n  EventEmitter.prototype.emit = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], ns, wildcard= this.wildcard;\n    var args,l,i,j, containsSymbol;\n\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all && this._all.length) {\n      handler = this._all.slice();\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this, type);\n          break;\n        case 2:\n          handler[i].call(this, type, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, type, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, arguments);\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);\n    } else {\n      handler = this._events[type];\n      if (typeof handler === 'function') {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler.call(this);\n          break;\n        case 2:\n          handler.call(this, arguments[1]);\n          break;\n        case 3:\n          handler.call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          args = new Array(al - 1);\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n          handler.apply(this, args);\n        }\n        return true;\n      } else if (handler) {\n        // need to make copy of handlers because list can change in the middle\n        // of emit call\n        handler = handler.slice();\n      }\n    }\n\n    if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this);\n          break;\n        case 2:\n          handler[i].call(this, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, args);\n        }\n      }\n      return true;\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return !!this._all;\n  };\n\n  EventEmitter.prototype.emitAsync = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], wildcard= this.wildcard, ns, containsSymbol;\n    var args,l,i,j;\n\n    if (type === 'newListener' && !this._newListener) {\n        if (!this._events.newListener) { return Promise.resolve([false]); }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var promises= [];\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all) {\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(this._all[i].call(this, type));\n          break;\n        case 2:\n          promises.push(this._all[i].call(this, type, arguments[1]));\n          break;\n        case 3:\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(this._all[i].apply(this, arguments));\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      switch (al) {\n      case 1:\n        promises.push(handler.call(this));\n        break;\n      case 2:\n        promises.push(handler.call(this, arguments[1]));\n        break;\n      case 3:\n        promises.push(handler.call(this, arguments[1], arguments[2]));\n        break;\n      default:\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n        promises.push(handler.apply(this, args));\n      }\n    } else if (handler && handler.length) {\n      handler = handler.slice();\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(handler[i].call(this));\n          break;\n        case 2:\n          promises.push(handler[i].call(this, arguments[1]));\n          break;\n        case 3:\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(handler[i].apply(this, args));\n        }\n      }\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\n      } else {\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return Promise.all(promises);\n  };\n\n  EventEmitter.prototype.on = function(type, listener, options) {\n    return this._on(type, listener, false, options);\n  };\n\n  EventEmitter.prototype.prependListener = function(type, listener, options) {\n    return this._on(type, listener, true, options);\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n    return this._onAny(fn, false);\n  };\n\n  EventEmitter.prototype.prependAny = function(fn) {\n    return this._onAny(fn, true);\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype._onAny = function(fn, prepend){\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if (!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    if(prepend){\n      this._all.unshift(fn);\n    }else{\n      this._all.push(fn);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype._on = function(type, listener, prepend, options) {\n    if (typeof type === 'function') {\n      this._onAny(type, listener);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    var returnValue= this, temp;\n\n    if (options !== undefined) {\n      temp = setupListener.call(this, type, listener, options);\n      listener = temp[0];\n      returnValue = temp[1];\n    }\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    if (this._newListener) {\n      this.emit('newListener', type, listener);\n    }\n\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener, prepend);\n      return returnValue;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else {\n      if (typeof this._events[type] === 'function') {\n        // Change to array.\n        this._events[type] = [this._events[type]];\n      }\n\n      // If we've already got an array, just add\n      if(prepend){\n        this._events[type].unshift(listener);\n      }else{\n        this._events[type].push(listener);\n      }\n\n      // Check for listener leak\n      if (\n        !this._events[type].warned &&\n        this._maxListeners > 0 &&\n        this._events[type].length > this._maxListeners\n      ) {\n        this._events[type].warned = true;\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\n      }\n    }\n\n    return returnValue;\n  };\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n      if(!leafs) return this;\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n      }\n    }\n\n    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          if (this._removeListener)\n            this.emit(\"removeListenerAny\", fn);\n          return this;\n        }\n      }\n    } else {\n      fns = this._all;\n      if (this._removeListener) {\n        for(i = 0, l = fns.length; i < l; i++)\n          this.emit(\"removeListenerAny\", fns[i]);\n      }\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (type === undefined) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if (this.wildcard) {\n      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;\n      if (!leafs) return this;\n      for (i = 0; i < leafs.length; i++) {\n        leaf = leafs[i];\n        leaf._listeners = null;\n      }\n      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    } else if (this._events) {\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function (type) {\n    var _events = this._events;\n    var keys, listeners, allListeners;\n    var i;\n    var listenerTree;\n\n    if (type === undefined) {\n      if (this.wildcard) {\n        throw Error('event name required for wildcard emitter');\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      keys = ownKeys(_events);\n      i = keys.length;\n      allListeners = [];\n      while (i-- > 0) {\n        listeners = _events[keys[i]];\n        if (typeof listeners === 'function') {\n          allListeners.push(listeners);\n        } else {\n          allListeners.push.apply(allListeners, listeners);\n        }\n      }\n      return allListeners;\n    } else {\n      if (this.wildcard) {\n        listenerTree= this.listenerTree;\n        if(!listenerTree) return [];\n        var handlers = [];\n        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n        searchListenerTree.call(this, handlers, ns, listenerTree, 0);\n        return handlers;\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      listeners = _events[type];\n\n      if (!listeners) {\n        return [];\n      }\n      return typeof listeners === 'function' ? [listeners] : listeners;\n    }\n  };\n\n  EventEmitter.prototype.eventNames = function(nsAsArray){\n    var _events= this._events;\n    return this.wildcard? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : (_events? ownKeys(_events) : []);\n  };\n\n  EventEmitter.prototype.listenerCount = function(type) {\n    return this.listeners(type).length;\n  };\n\n  EventEmitter.prototype.hasListeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers.length > 0;\n    }\n\n    var _events = this._events;\n    var _all = this._all;\n\n    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  EventEmitter.prototype.waitFor = function (event, options) {\n    var self = this;\n    var type = typeof options;\n    if (type === 'number') {\n      options = {timeout: options};\n    } else if (type === 'function') {\n      options = {filter: options};\n    }\n\n    options= resolveOptions(options, {\n      timeout: 0,\n      filter: undefined,\n      handleError: false,\n      Promise: Promise,\n      overload: false\n    }, {\n      filter: functionReducer,\n      Promise: constructorReducer\n    });\n\n    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {\n      function listener() {\n        var filter= options.filter;\n        if (filter && !filter.apply(self, arguments)) {\n          return;\n        }\n        self.off(event, listener);\n        if (options.handleError) {\n          var err = arguments[0];\n          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));\n        } else {\n          resolve(toArray.apply(null, arguments));\n        }\n      }\n\n      onCancel(function(){\n        self.off(event, listener);\n      });\n\n      self._on(event, listener, false);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    })\n  };\n\n  function once(emitter, name, options) {\n    options= resolveOptions(options, {\n      Promise: Promise,\n      timeout: 0,\n      overload: false\n    }, {\n      Promise: constructorReducer\n    });\n\n    var _Promise= options.Promise;\n\n    return makeCancelablePromise(_Promise, function(resolve, reject, onCancel){\n      var handler;\n      if (typeof emitter.addEventListener === 'function') {\n        handler=  function () {\n          resolve(toArray.apply(null, arguments));\n        };\n\n        onCancel(function(){\n          emitter.removeEventListener(name, handler);\n        });\n\n        emitter.addEventListener(\n            name,\n            handler,\n            {once: true}\n        );\n        return;\n      }\n\n      var eventListener = function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        resolve(toArray.apply(null, arguments));\n      };\n\n      var errorListener;\n\n      if (name !== 'error') {\n        errorListener = function (err){\n          emitter.removeListener(name, eventListener);\n          reject(err);\n        };\n\n        emitter.once('error', errorListener);\n      }\n\n      onCancel(function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        emitter.removeListener(name, eventListener);\n      });\n\n      emitter.once(name, eventListener);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  }\n\n  var prototype= EventEmitter.prototype;\n\n  Object.defineProperties(EventEmitter, {\n    defaultMaxListeners: {\n      get: function () {\n        return prototype._maxListeners;\n      },\n      set: function (n) {\n        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n          throw TypeError('n must be a non-negative number')\n        }\n        prototype._maxListeners = n;\n      },\n      enumerable: true\n    },\n    once: {\n      value: once,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  Object.defineProperties(prototype, {\n      _maxListeners: {\n          value: defaultMaxListeners,\n          writable: true,\n          configurable: true\n      },\n      _observers: {value: null, writable: true, configurable: true}\n  });\n\n  if (typeof define === 'function' && define.amd) {\n     // AMD. Register as an anonymous module.\n    define(function() {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = EventEmitter;\n  }\n  else {\n    // global for any kind of environment.\n    var _global= new Function('','return this')();\n    _global.EventEmitter2 = EventEmitter;\n  }\n}();\n"]},"metadata":{},"sourceType":"script"}