{"ast":null,"code":"'use strict';\n\nvar UPPER32 = Math.pow(2, 32);\nvar warnedPrecision = false;\n\nfunction warnPrecision() {\n  if (!warnedPrecision) {\n    warnedPrecision = true;\n    console.warn('CBOR 64-bit integer array values may lose precision. No further warnings.');\n  }\n}\n/**\n * Unpacks 64-bit unsigned integer from byte array.\n * @param {Uint8Array} bytes\n*/\n\n\nfunction decodeUint64LE(bytes) {\n  warnPrecision();\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var arr = new Array(arrLen);\n\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = uint32View[si + 1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n\n  return arr;\n}\n/**\n * Unpacks 64-bit signed integer from byte array.\n * @param {Uint8Array} bytes\n*/\n\n\nfunction decodeInt64LE(bytes) {\n  warnPrecision();\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var int32View = new Int32Array(buffer);\n  var arr = new Array(arrLen);\n\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = int32View[si + 1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n\n  return arr;\n}\n/**\n * Unpacks typed array from byte array.\n * @param {Uint8Array} bytes\n * @param {type} ArrayType - desired output array type\n*/\n\n\nfunction decodeNativeArray(bytes, ArrayType) {\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  return new ArrayType(buffer);\n}\n/**\n * Support a subset of draft CBOR typed array tags:\n *   <https://tools.ietf.org/html/draft-ietf-cbor-array-tags-00>\n * Only support little-endian tags for now.\n */\n\n\nvar nativeArrayTypes = {\n  64: Uint8Array,\n  69: Uint16Array,\n  70: Uint32Array,\n  72: Int8Array,\n  77: Int16Array,\n  78: Int32Array,\n  85: Float32Array,\n  86: Float64Array\n};\n/**\n * We can also decode 64-bit integer arrays, since ROS has these types.\n */\n\nvar conversionArrayTypes = {\n  71: decodeUint64LE,\n  79: decodeInt64LE\n};\n/**\n * Handles CBOR typed array tags during decoding.\n * @param {Uint8Array} data\n * @param {Number} tag\n */\n\nfunction cborTypedArrayTagger(data, tag) {\n  if (tag in nativeArrayTypes) {\n    var arrayType = nativeArrayTypes[tag];\n    return decodeNativeArray(data, arrayType);\n  }\n\n  if (tag in conversionArrayTypes) {\n    return conversionArrayTypes[tag](data);\n  }\n\n  return data;\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = cborTypedArrayTagger;\n}","map":{"version":3,"sources":["/Users/julien/Sites/react-ros-robot/node_modules/roslib/src/util/cborTypedArrayTags.js"],"names":["UPPER32","Math","pow","warnedPrecision","warnPrecision","console","warn","decodeUint64LE","bytes","byteLen","byteLength","offset","byteOffset","arrLen","buffer","slice","uint32View","Uint32Array","arr","Array","i","si","lo","hi","decodeInt64LE","int32View","Int32Array","decodeNativeArray","ArrayType","nativeArrayTypes","Uint8Array","Uint16Array","Int8Array","Int16Array","Float32Array","Float64Array","conversionArrayTypes","cborTypedArrayTagger","data","tag","arrayType","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar UPPER32 = Math.pow(2, 32);\n\nvar warnedPrecision = false;\nfunction warnPrecision() {\n  if (!warnedPrecision) {\n    warnedPrecision = true;\n    console.warn('CBOR 64-bit integer array values may lose precision. No further warnings.');\n  }\n}\n\n/**\n * Unpacks 64-bit unsigned integer from byte array.\n * @param {Uint8Array} bytes\n*/\nfunction decodeUint64LE(bytes) {\n  warnPrecision();\n\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = uint32View[si+1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n\n  return arr;\n}\n\n/**\n * Unpacks 64-bit signed integer from byte array.\n * @param {Uint8Array} bytes\n*/\nfunction decodeInt64LE(bytes) {\n  warnPrecision();\n\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var int32View = new Int32Array(buffer);\n\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = int32View[si+1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n\n  return arr;\n}\n\n/**\n * Unpacks typed array from byte array.\n * @param {Uint8Array} bytes\n * @param {type} ArrayType - desired output array type\n*/\nfunction decodeNativeArray(bytes, ArrayType) {\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  return new ArrayType(buffer);\n}\n\n/**\n * Support a subset of draft CBOR typed array tags:\n *   <https://tools.ietf.org/html/draft-ietf-cbor-array-tags-00>\n * Only support little-endian tags for now.\n */\nvar nativeArrayTypes = {\n  64: Uint8Array,\n  69: Uint16Array,\n  70: Uint32Array,\n  72: Int8Array,\n  77: Int16Array,\n  78: Int32Array,\n  85: Float32Array,\n  86: Float64Array\n};\n\n/**\n * We can also decode 64-bit integer arrays, since ROS has these types.\n */\nvar conversionArrayTypes = {\n  71: decodeUint64LE,\n  79: decodeInt64LE\n};\n\n/**\n * Handles CBOR typed array tags during decoding.\n * @param {Uint8Array} data\n * @param {Number} tag\n */\nfunction cborTypedArrayTagger(data, tag) {\n  if (tag in nativeArrayTypes) {\n    var arrayType = nativeArrayTypes[tag];\n    return decodeNativeArray(data, arrayType);\n  }\n  if (tag in conversionArrayTypes) {\n    return conversionArrayTypes[tag](data);\n  }\n  return data;\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = cborTypedArrayTagger;\n}\n"]},"metadata":{},"sourceType":"script"}